#+title:     Minishell
#+author:    Chris Haikney
#+email:     chaikney@student.42urduliz.com
* Make a plan for minishell.
** Video call on Monday
SCHEDULED: <2024-06-10 Mon>
** [ ] Implement builtins handling
- Identify the ones we have to have
- Parse them and record them (how? as ENUM?)
- match them with our functions
- implement those functions.

[[file:~/Documents/00_WorkInProgress/2023_04_42UrdulizCurso/minishell/minishell/minishell.c::printf("%s: Command not found\n", cmd->argv\[0\]);]]
* My minishell tasks
** TODO Get pipex bonus parts working
I need the heredoc and the output to work. (The second is easier, basically done)
** TODO I don't think any commands work ATM (path problem)
** DONE watch shell in 10 min video
https://www.youtube.com/watch?v=k6TTj4C0LF0
Some brief pieces on parsing but the majority of fork exec etc. That I have done.
Parse the input looking for tokens.(NULL-termed). Outputs into a command struct like this:
#+begin_src c
#define MAXARGS 128	// apparently needs to be a define not a variable.

struct command {
	int argc;	// number of args}
	char *argv[MAXARGS];	// the arguments (inc command as 0)
    enum builtin_t {
	NONE, QUIT, JOBS, BG, FG} builtin;	// is argv[0] a builtin command?
};
#+end_src
some kind of flagging out for builtins
With backgrounding, you do a conditional thing before the waitpid
** DONE Find out about what the readline library does.
man readline is a good start: get a line of input from the user with editing.
...so we just have to call that and parse what it gives us?
#+begin_src c
#include <stdio.h>
#include <readline/readline.h>
#include <readline/history.h>

char	*readline(const char *prompt);
#+end_src
returns the line from the user, or an empty string. (Some nuance around EOF characters)
Does this also handle history for us?

*** Are we allowed to use the history parts?
src_shell{man 3 history}

*** NOTE I had to install readline-dev to get the header files.
** [X] Adapt output redirection from pipex
So run_child_in_pipe is like an internal thing at the moment, and end of pipe output redirection requires things done to the files that in pipex are done in main like this:
#+begin_src c
	dup2(out_file, STDOUT_FILENO);
        close(out_file);
        run_command(argv[(argc - 2)], envp);
        close(in_file);
#+end_src
[[file:~/code/42_Urduliz/2023_Curso/pipex/pipex.c::dup2(out_file, STDOUT_FILENO);
 close(out_file);
 run_command(argv\[(argc - 2)\], envp);
 close(in_file);]]
* Basic requirements
- display a prompt
  This is handled by an input to readline.
- working history
  (I assume that means record and scrollback)
- search for and launch an executable with PATH
  (I have this from pipex)
- "avoid using more than one global variable to indicate a received signal"
  was  this part of minitalk?
- Not interpret unclosed quotes or special characters which are not required by the subject such as \ (backslash) or ; (semicolon).
- handle single quote ''
  stops interpretation of metacharacters
- handle double quote ""
  stops interpretation of metacharacters *except* $
- Implement redirections - I have code for all these except <<
  - < redirect input
  - > redirect output
  - << read input until delimiter
  - >> redirect output in append mode
- Implement pipes |
  This is pipex, just need to interpret the commands correctly.
- handle env vars
  - expand $WHATEVER to its values (before interpreting a command?)
- Handle $? - expand to the last exit status ("most recently executed foreground pipeline")
- Handle ctrl-C, ctrl-D and ctrl-\
  What are the signals that these each send?
- builtins to code:
  - echo with -n (newline or not)
  - cd with only a relative or absolute path
  - pwd (no options)
  - unset (no options)
  - env, no options or args
  - exit no options.
* General notes
** Signals and ctrl sequences
You can use stty to check or change the characters that generate signals
src_sh{stty -a}
CTRL-c = SIGINT
CTRL-d = EOF (which amounts to quitting the shell; useful for the command parsing?)
CTRL-\ = SIGQUIT (is that a real one?)
** Parsing is a thing we need to do.
People suggest splitting parsing and execution of tasks. I think that with pipex the execution is partly there.
"abstract syntax trees" versus a simple split.
What are the parts of what we would receive as input?
- commands
- special characters for control -- pipes, redirects and that
- command options.
...how would we tell the difference between a command and its options.
The first thing that we read would be a command - NO, it might be input redirection. Or here_doc, etc.
Remember escaping! \  to include a  space.
*** What is the structure of input?
- command
- arguments - the two simple, one-at-a-time parts.
- variables - to be expanded
- quote marks - affect parsing and variable expansion
- pipe - there will be more than one command here
** Things involving ENV
working  directory is always in ENV -- constantly manipulated, changed.
pwd must therefore amount to "print this thing from my ENV"
cd  = change value in env
note  that the prompt line is probably reading from this as well.
Also note: there are permitted functions that do some of these things without having to directly manipulate PATH (which is not a file, remember),
*** [2024-07-30 Tue] Reason why getenv is unrealiable in minishell

#+begin_quote
    The getenv function returns a pointer to a string associated with the matched list member. The string pointed to shall not be modified by the program but may be overwritten by a subsequent call to the getenv function.

This paragraph gives an implementation the latitude, for example, to return a pointer to a statically allocated buffer. Consequently, do not store this pointer because the string data it points to may be overwritten by a subsequent call to the getenv() function or invalidated by modifications to the environment. This string should be referenced immediately and discarded. If later use is anticipated, the string should be copied so the copy can be safely referenced as needed.

The getenv() function is not thread-safe. Make sure to address any possible race conditions resulting from the use of this function.
#+end_quote

https://wiki.sei.cmu.edu/confluence/display/c/ENV34-C.+Do+not+store+pointers+returned+by+certain+functions
** making a prompt
- what should it show?
  current directory.
- username
- fancy things in a prompt what are there?
** history
Very linked to readline behaviour. Which in turn is very linked to bash behaviour.
This is extremely useful: http://web.mit.edu/gnu/doc/html/rlman_2.html
Suggests creating a readline_initialise function to set up the desired behaviour.
For example, default is to complete filenames on TAB. Might we want something else? Scrollbak with up and down for example?
See also: https://tiswww.case.edu/php/chet/readline/history.html
*** Allowed readline functions and what they do
**** rl_clear_history
Function: void clear_history (void)
Clear the history list by deleting all the entries.
...useful on exit, perhaps?
**** rl_on_new_line,
Function: int rl_on_new_line ()
Tell the update routines that we have moved onto a new (empty) line, usually after ouputting a newline.
...what use is that?
**** rl_replace_line
Not found
**** rl_redisplay
Function: int rl_redisplay ()

Change what's displayed on the screen to reflect the current contents of rl_line_buffer.
**** add_history
This one is relatively simple - add the line to the history list. Should check that it is not empty before doing that.
*** So what do we need from history?
want things to be collected.
Can we do persistent history across sesssions? I don't see any functions that would permit that, or any configuration.
Would readline pick up an existing .inputrc file?
* TODO Find and read minishell evaluation documents
* Quoting types
https://flokoe.github.io/bash-hackers-wiki/syntax/quoting/
...some of that is unclear, some is useful.
** weak quoting, "double quotes"
#+begin_quote
Inside a weak-quoted string there's no special interpretation of:

    spaces as word-separators (on initial command line splitting and on word splitting!)
    single-quotes to introduce strong-quoting (see below)
    characters for pattern matching
    tilde expansion
    pathname expansion
    process substitution

Everything else, **especially parameter expansion**, is performed!
#+end_quote
** strong quoting, 'single quotes'
This one seems easiest to implement. You copy everything until the closing ' is reached. (Except for something unclear for this subject about backslash-escaped characters)
#+begin_quote
Strong quoting is very easy to explain:

Inside a single-quoted string nothing is interpreted, except the single-quote that closes the string.
#+end_quote
